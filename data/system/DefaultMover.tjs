// DefaultMover.tjs - 图层自动移动的默认处理程序
// Copyright (C)2001-2009, W.Dee and contributors  改变和分发是自由的

class LinearMover
{
    // 直线插值

    var layer; // 图层
    var path; // 点数组
    var time; // 通过点所需的时间
    var accel; // 是否进行加速度运动
    var pointCount; // path.count -1
    var finalFunction; // 移动结束时调用的函数
    var startTick; // 移动开始时的时间戳
    var totalTime; // 总时间
    var delayTimer; // 等待开始移动的计时器
    var moving = false; // 是否正在移动
    var first = true; // 是否是第一次调用处理程序
    var nextStop = false; // 是否在下一次调用处理程序时停止

    function LinearMover(layer, path, time, accel, finalfunction)
    {
        this.layer = layer;
        this.path = path;
        this.time = time;
        this.accel = accel;
        this.finalFunction = finalfunction;
        totalTime = (pointCount = (path.count \ 3 - 1)) * time;
    }

    function finalize()
    {
        stopMove();
        if(delayTimer !== void) invalidate delayTimer;
    }

    function startMove(delay)
    {
        // 开始移动
        if(delay != 0)
        {
            delayTimer = new Timer(onDelayTimer, '');
            delayTimer.interval = delay;
            delayTimer.enabled = true;
            moving = true;
        }
        else
        {
            System.addContinuousHandler(handler); // 添加到 ContinuousHandlers
            moving = true;
        }
    }

    function onDelayTimer()
    {
        // delayTimer 触发
        delayTimer.enabled = false;
        System.addContinuousHandler(handler);
    }

    function stopMove()
    {
        // 停止移动
        if(moving)
        {
            // 移动到最终位置
            if(layer isvalid)
            {
                var idx = int(pointCount*3);
                var p = path;
                layer.setPos(p[idx], p[idx+1]);
                layer.opacity = p[idx+2];
            }
            System.removeContinuousHandler(handler);
            moving = false;
            finalFunction();
        }
    }

    function handler(tick)
    {
        // 移动中调用
        if(nextStop || !(layer isvalid)) { stopMove();  return; }
        if(first) startTick = tick, first = false;
        tick -= startTick;
        if(tick >= totalTime)
        {
            nextStop = true;
            var idx = int(pointCount*3);
            var p = path;
            layer.setPos(p[idx], p[idx+1]);
            layer.opacity = p[idx+2];
            return;
        }

        if(accel < 0)
        {
            // 上弦 ( 最初移动快，逐渐变慢 )
            tick = 1.0 - tick / totalTime;
            tick = Math.pow(tick, -accel);
            tick = int ( (1.0 - tick) * totalTime );
        }
        else if(accel > 0)
        {
            // 下弦 ( 最初移动慢，逐渐变快 )
            tick = tick / totalTime;
            tick = Math.pow(tick, accel);
            tick = int ( tick * totalTime );
        }

        move(tick);
    }

    function move(tick)
    {
        var index = tick \ time * 3;
        var ratio = tick % time / time;
        var p = path;
        var sx = p[index];
        var sy = p[index+1];
        var so = p[index+2];
        var ex = p[index+3];
        var ey = p[index+4];
        var eo = p[index+5];

        var l = int((ex-sx)*ratio + sx);
        var t = int((ey-sy)*ratio + sy);
        var o = eo >= 256 ? so : int((eo-so)*ratio + so);

        layer.setPos(l, t);
        layer.opacity = o;
    }
}


class SplineMover extends LinearMover
{
    // 样条插值
    var zx = []; // 样条工作数组
    var zy = []; // 样条工作数组

    function SplineMover(layer, path, time, accel, finalfunction)
    {
        super.LinearMover(...);

        if(path.count < 9)
        {
            // 少于 3 个点 ( 其中 2 个点 ) 无法插值
            throw new Exception("请指定至少 2 个点");
        }

        // 计算样条插值所需的工作数组
        var points = path.count \ 3;
        var tmpx = [], tmpy = [];
        var tx = zx, ty = zy;
        tx[0] = 0;
        ty[0] = 0;
        tx[points-1] = 0;
        ty[points-1] = 0;

        for(var i = points-2, pi = path.count-6; i >= 0; i--, pi -= 3)
        {
            tmpx[i+1] = (path[pi + 3] - path[pi  ]);
            tmpy[i+1] = (path[pi + 4] - path[pi+1]);
        }

        tx[1] = tmpx[2] - tmpx[1] - tx[0];
        ty[1] = tmpy[2] - tmpy[1] - ty[0];

        tmpx[1] = 4;
        tmpy[1] = 4;

        var lim = points - 2;
        for(var i = 1, pi = 3; i < lim; i++, pi += 3)
        {
            var x = 1 / tmpx[i];
            var y = 1 / tmpy[i];
            tx[i+1] = tmpx[i+2] - tmpx[i+1] - tmpx[i] * x;
            ty[i+1] = tmpy[i+2] - tmpy[i+1] - tmpy[i] * y;
            tmpx[i+1] = 4 - x;
            tmpy[i+1] = 4 - y;
        }

        tx[points-2] -= tx[points-1];
        ty[points-2] -= ty[points-1];

        for(var i = points-2, pi = path.count-6; i>0; i--, pi -= 3)
        {
            tx[i] = (tx[i] - tx[i+1]) / tmpx[i];
            ty[i] = (ty[i] - ty[i+1]) / tmpy[i];
        }
    }

    function move(tick)
    {
        var index;
        var pindex = (index = tick \ time) * 3;
        var d = tick % time / time;

        var p = path;

        var l = (((zx[index+1] - zx[index])*d +
                zx[index]*3)*d +
                ((p[pindex + 3] - p[pindex]) -
                (zx[index]*2 + zx[index+1]))) * d +
                p[pindex];

        var t = (((zy[index+1] - zy[index])*d +
                zy[index]*3)*d +
                ((p[pindex + 4] - p[pindex+1]) -
                (zy[index]*2 + zy[index+1]))) * d +
                p[pindex+1];

        var so = p[pindex+2];
        var eo = p[pindex+5];

        var o = eo >= 256 ? so : int((eo-so)*d + so);

        layer.setPos(l, t);
        layer.opacity = o;
    }

}


class LinearFrameMover
{
    // 直线插值
    var layer;				// 图层
    var path;				// 帧数组 -> 包含帧编号, x, y, opacity
    var fps;				// 帧率
    var pointCount;			// path.count -1
    var finalFunction;		// 移动结束时调用的函数
    var startTick;			// 移动开始时的时间戳
    var totalTime;			// 总时间
    var moving = false;		// 是否正在移动
    var first = true;		// 是否是第一次调用处理程序
    var nextStop = false;	// 是否在下一次调用处理程序时停止

    var offset_x = 0;
    var offset_y = 0;
    var curPoint;

    function LinearFrameMover(layer, path, fps, finalfunction, offset_x, offset_y)
    {
        this.layer = layer;
        this.path = path;
        this.fps = fps;
        this.finalFunction = finalfunction;
        this.offset_x = offset_x;
        this.offset_y = offset_y;
        pointCount = (path.count \ 4 - 1);
        totalTime = (path[int(pointCount*4)] * 1000) \ fps;
    }

    function finalize() {
        stopMove();
    }

    function startMove() {
        first = true;
        System.addContinuousHandler(handler); // 添加到 ContinuousHandlers
        moving = true;
    }

    function stopMove() {
        // 停止移动
        if( moving ) {
            // 移动到最终位置
            if(layer isvalid) {
                var idx = int(pointCount*4);
                var p = path;
                layer.setPos(offset_x+p[idx+1], offset_y+p[idx+2]);
                layer.opacity = p[idx+3];
            }
            System.removeContinuousHandler(handler);
            moving = false;
            finalFunction();
        }
    }

    function handler(tick) {
        // 移动中调用
        if(nextStop || !(layer isvalid)) { stopMove();  return; }
        if(first) startTick = tick, first = false, curPoint = 0;
        tick -= startTick;
        if( tick >= totalTime ) {
            nextStop = true;
            var idx = int(pointCount*4);
            var p = path;
            layer.setPos(offset_x+p[idx+1], offset_y+p[idx+2]);
            layer.opacity = p[idx+3];
            return;
        }
        move(tick);
    }

    function move(tick) {
        var idx = int(curPoint*4);
        var p = path;
        var curTime = (p[idx] * 1000) \ fps;
        var nextIdx = idx + 4;
        var nextTime = (p[nextIdx] * 1000) \ fps;
        if( tick > nextTime ) {
            curPoint++;
            idx = int(curPoint*4);
            curTime = (p[idx] * 1000) \ fps;
            nextIdx = idx + 4;
            nextTime = (p[nextIdx] * 1000) \ fps;
        }

        var duration = nextTime - curTime;
        var diff = (tick - curTime);

        var ratio = diff / duration;
        var p = path;
        var sx = p[idx+1];
        var sy = p[idx+2];
        var so = p[idx+3];

        var ex = p[nextIdx+1];
        var ey = p[nextIdx+2];
        var eo = p[nextIdx+3];

        var l = int((ex-sx)*ratio + sx);
        var t = int((ey-sy)*ratio + sy);
        var o = eo >= 256 ? so : int((eo-so)*ratio + so);

        layer.setPos(offset_x+l, offset_y+t);
        layer.opacity = o;
    }
}