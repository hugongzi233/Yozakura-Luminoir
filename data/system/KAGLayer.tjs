// KAGLayer.tjs - KAG 的基本层类
// 版权所有 (C)2001-2009, W.Dee 和贡献者  修改和分发是自由的

/*
 层相关的类层次结构

 Layer ( 吉里吉里本地类 )
	|
	+-- KAGLayer ( 本文件 )
			 |
			 +-- AnimationLayer ( AnimationLayer.tjs )
			 |    |
			 |    +-- ClickGlyphLayer ( AnimationLayer.tjs )
			 |    |
			 |    +-- GraphicLayer ( GraphicLayer.tjs )
			 |         |
			 |         +-- BaseLayer ( GraphicLayer.tjs )
			 |         |
			 |         +-- CharacterLayer ( GraphicLayer.tjs )
			 |
			 +-- MessageLayer ( MessageLayer.tjs )
			 |
			 +-- ButtonLayer ( ButtonLayer.tjs )
			 |    |
			 |    +-- LinkButtonLayer ( MessageLayer.tjs )
			 |    |
			 |    +-- LButtonLayer ( HistoryLayer.tjs )
			 |
			 +-- EditLayer ( EditLayer.tjs )
			 |    |
			 |    +-- LinkEditLayer ( MessageLayer.tjs )
			 |
			 +-- CheckBoxLayer ( CheckBoxLayer.tjs )
						|
						+-- LinkCheckBoxLayer ( MessageLayer.tjs )
*/

/*
　关于有点难以理解的过渡结束时的行为的备忘

　吉里吉里在过渡结束时，如果有过渡源(src=对方)，
并且包含子层(children=true)，则会交换对方和自身的层树，
如果不包含子层(children=false)，则保持子层的绝对树位置不变并交换对方。

　只有背景层可以进行不包含子层的过渡。

进行过渡时，会进行上述的“交换”，但吉里吉里本体的
交换会交换 name 等重要信息，
所以通过 GraphicLayer.exchangeInfo 交换内容。

另外，如果在 trans 属性中指定了 exchange=true，则两者的层会交换，
但如果指定了 exchange=false (默认)，则需要将过渡源(src)的信息复制到过渡目标。

没有 src 时，进行单独层的过渡，因此不需要考虑这些，但结束时子层会全部隐藏。

・消息层、前景层在没有 src 的情况下进行过渡 (children=true)
　不需要做任何事情，但结束后这些子层会自动隐藏。

・消息层、前景层在有 src 的情况下进行过渡 (children=true)
　交换重要信息，如果 exchange=false，还需要将过渡源的信息复制到过渡目标。
　但在复制时不复制窗口的可见性信息。

・背景层在没有 src 的情况下进行过渡 (children=true)
　不需要做任何事情，但结束时子层会隐藏。

・背景层在没有 src 的情况下进行过渡 (children=false)
　真的不需要做任何事情。

・背景层在有 src 的情况下进行过渡 (children=true)
　交换重要信息，并且对子层也发出“交换重要信息”的指示。
　如果 exchange=false，还需要将过渡源的信息复制到过渡目标。
　这也对子层发出指示。

・背景层在有 src 的情况下进行过渡 (children=false)
　交换重要信息，不对子层发出“交换重要信息”的指示。
　如果 exchange=false，还需要将过渡源的信息复制到过渡目标。
　这也不对子层发出指示。

*/

class KAGLayer extends Layer
{
	// KAG で用いる背景/前景レイヤ、メッセージレイヤ、ボタンレイヤなどの基本クラス
	var inTransition = false; // トランジション中か
	var transExchange = false; // トランジション終了時に入れ替えを行うか
	var transWithChildren = false; // トランジションは子レイヤも含めて行うか

	var moveObject; // 現在進行中の自動移動用オブジェクト(進行していないときはvoid)

	function KAGLayer(win, par)
	{
		super.Layer(win, par);
	}

	function finalize()
	{
		invalidate moveObject if moveObject !== void;
		super.finalize(...);
	}

	function setOptions(elm)
	{
		// elm に従ってレイヤのオプションを設定
		visible = +elm.visible if elm.visible !== void;
		left = +elm.left if elm.left !== void;
		top = +elm.top if elm.top !== void;
		opacity = +elm.opacity if elm.opacity !== void;

		if(elm.modal !== void)
		{
			// this would not work well
			var modal = elm.modal;
			if(modal) setMode(), focus(); else removeMode();
		}

		absolute = +elm.index if elm.index !== void;
	}

	function loadImages(storage, key)
	{
		// loadImages オーバーライド
		dm("Loading images with storage:", storage, "and key:", key);
		key = adjustColorKey(key);
		return super.loadImages(storage, key);
	}

	function adjustColorKey(key)
	{
		// 文字列で与えられたカラーキーの変換
		if(key === void)
			key = clNone;
		else if(typeof key == "String")
		{
			if(key == "adapt")
				key = clAdapt; // adaptive color key
			else
			{
				if(key.length >= 7)
					key = +key;
				else
					key = +key + 0x3000000; // 0x3000000 = パレットインデックスによる指定
			}
		}
		return key;
	}

	function assignImages(src, copyvisiblestate = false)
	{
		// assignImages オーバーライド
		// src の「目に見える」情報をこのレイヤにコピーする
		// コピーされる内容は、
		// ・透明度
		// ・位置
		// ・表示サイズ
		// ・レイヤ内画像表示位置(imageLeft, imageTop)
		//  ( 上記３つは copyvisiblestate = true のばあい )
		// ・画像サイズ
		// ・レイヤ画像、領域画像
		super.assignImages(src);
		if(copyvisiblestate)
		{
			var su = super;
			su.visible = src.visible;
			su.opacity = src.opacity;
			su.absolute = src.absolute if !src.isPrimary && src.parent.absoluteOrderMode;
			su.type = src.type;
			su.setPos(src.left, src.top, src.width, src.height);
			su.setImagePos(src.imageLeft, src.imageTop);
		}
	}

	function assignVisibleState(src)
	{
		// src から上記 assignImages のうち、copyvisiblestate = true に
		// したときだけにコピーされる情報をコピー
		visible = src.visible;
		opacity = src.opacity;
		absolute = src.absolute if !src.isPrimary && src.parent.absoluteOrderMode;
		type = src.type;
		setPos(src.left, src.top, src.width, src.height);
		setImagePos(src.imageLeft, src.imageTop);
	}

	function beginTransition(elm, src)
	{
		// beginTransition オーバーライド
		// elm に従い、トランジションを開始する
		// src にはトランジションの相手を指定
//		stopTransition(); // 現在のトランジションは停止

		if(elm.exchange !== void) transExchange = +elm.exchange; else transExchange = false;
		var method = elm.method;
		if(elm.time !== void)
		{
			elm.time = 1 if +elm.time == 0; // 時間に 0 は指定できないので
		}
		if(method === void)
		{
			method = 'universal'; // デフォルトでユニバーサル
		}
		else if(method == 'scroll')
		{
			// パラメータの変換
			switch(elm.from)
			{
			case 'left': elm.from = sttLeft; break;
			case 'top': elm.from = sttTop; break;
			case 'right': elm.from = sttRight; break;
			case 'bottom': elm.from = sttBottom; break;
			}
			switch(elm.stay)
			{
			case 'nostay': elm.stay = ststNoStay; break;
			case 'stayback': elm.stay = ststStaySrc; break;
			case 'stayfore': elm.stay = ststStayDest; break;
			default: elm.stay = ststNoStay; break;
			}
		}
		var withchildren = elm.children;
		if(withchildren === void)
			withchildren = true;
		else
			withchildren = +withchildren;
		transWithChildren = withchildren;
		inTransition = true;
		window.transCount++; // 進行中のトランジションの数を増やす
		super.beginTransition(method, withchildren, src, elm);
	}

	function onTransitionCompleted(dest, src)
	{
		super.onTransitionCompleted(...);
		if(window != null)
		{
			inTransition = false;
			window.transCount--; // 進行中のトランジションの数を減らす
			atEndOfTransition(src, transWithChildren, transExchange);
			window.onLayerTransitionCompleted(this, dest, src);
		}
	}

	function atEndOfTransition(src, withchildren, exchange)
	{
		// 必要に応じて オーバーライドすること
		// トランジションが終了したときに呼ばれる。
		// レイヤ単独でトランジションが行われた場合は src は null になる。
		// そうでない場合、exchange が true の時は、src と 自分の内容
		// を取り替え、そうでなければ src に自分の内容
		// をコピー。
		// 子レイヤも含めてトランジションが行われた場合は withchildren が
		// true になる。
		// root は、トランジションの大本に対して呼ばれるときに true になる。
	}

	function beginMove(elm)
	{
		// elm に従い自動移動を開始する
		stopMove();

		// path の分解
		var array = [].split("(), ", elm.path, , true);
		for(var i = array.count-1; i>=0; i--) array[i+3] = +array[i];
		array[0] = left;
		array[1] = top;
		array[2] = opacity;

		// 移動用オブジェクトの作成
		if(elm.spline !== void && +elm.spline)
		{
			// スプライン補間
			moveObject = new SplineMover(this, array, +elm.time,
				elm.accel === void ? 0 : +elm.accel, moveFinalFunction);
		}
		else
		{
			// 直線補間
			moveObject = new LinearMover(this, array, +elm.time,
				elm.accel === void ? 0 : +elm.accel, moveFinalFunction);
		}
		window.moveCount++;
		moveObject.startMove(+elm.delay);
	}

	function moveFinalFunction()
	{
		// 自動移動が終了するときに呼ばれる関数
		window.moveCount--;
		window.onLayerMoveStop();
	}

	function stopMove()
	{
		if(moveObject !== void) invalidate moveObject, moveObject = void;
	}

	// フレーム番号を指定したmove
	function beginFrameMove(elm)
	{
		// elm に従い自動移動を開始する
		stopMove();

		var ox = elm.ox === void ? 0 : +elm.ox;
		var oy = elm.oy === void ? 0 : +elm.oy;
		var fps = elm.fps === void ? 30 : +elm.fps;

		// path の分解
		var array = [].split("(), ", elm.path, , true);
		for(var i = array.count-1; i>=0; i--) array[i+4] = +array[i];
		array[0] = 0;
		array[1] = left - ox;
		array[2] = top - oy;
		array[3] = opacity;

		// 移動用オブジェクトの作成
		moveObject = new LinearFrameMover(this, array, fps, moveFinalFunction, ox, oy );

		window.moveCount++;
		moveObject.startMove();
	}

	function store()
	{
		// 辞書配列に現在の状態を保存する
		var dic = %[];
		dic.left = left;
		dic.top = top;
		dic.width = width;
		dic.height = height;
		dic.imageWidth = imageWidth;
		dic.imageHeight = imageHeight;
		dic.opacity = opacity;
		dic.visible = visible;
		dic.imageLeft = imageLeft;
		dic.imageTop = imageTop;
		dic.absolute = absolute;
		dic.type = type;
		return dic;
	}

	function restore(dic)
	{
		// 辞書配列 dic から情報を読み出し、このレイヤに設定する
		setImageSize(dic.imageWidth, dic.imageHeight);
		setPos(dic.left, dic.top, dic.width, dic.height);
		setImagePos(dic.imageLeft, dic.imageTop);
		opacity = dic.opacity;
		visible = dic.visible;
		absolute = dic.absolute if !isPrimary && dic.absolute !== void;
		type = dic.type if !isPrimary && dic.type !== void;
	}

	/**
	 * レイヤへの色反映処理
	 * @param left
	 * @param top
	 * @param width
	 * @param height
	 * @param color 塗りつぶす色(マスク値を含む）
	 * @param mode 合成モード
	 */
	function fillOperateRect(left, top, width, height, color, mode)
	{
		var tw = 128;
		var th = 64;
		var fillLayer = new global.Layer(window, this);
		// 元々吉里吉里のものなら、不透明の一色レイヤーを、不透明度を指定して描画。
		// PhotoShop準拠のものなら、半透明の一色レイヤーを、透明度を指定せず(opacity=255)に描画。
		var orgmodes	= %[ltOpaque=>1,ltAlpha=>1,ltAddAlpha=>1,ltAdditive=>1,ltSubtractive=>1,ltMultiplicative=>1,ltDodge=>1,ltLighten=>1,ltDarken=>1,ltScreen=>1];
		fillLayer.setSize(tw, th);
		var opacity	= 255;
		var lastface = face, lastha = holdAlpha;
		if(orgmodes[mode])
		{
			fillLayer.fillRect(0, 0, tw, th, color | 0xFF000000);
			opacity = (color >> 24) & 0xFF;
			face	= dfOpaque;
		}
		else
			fillLayer.fillRect(0, 0, tw, th, color);
		holdAlpha	= true if !isPrimary;
		var x = 0;
		var y = 0;
		while (y < height) {
			var x2 = x;
			while (x2 < width) {
				//Debug.message("pos:" + x2 + "," + y);
				global.Layer.operateRect(x2, y, fillLayer, 0, 0, tw, th, mode, opacity);
				x2 += tw;
			}
			y += th;
		}
		face = lastface, holdAlpha = lastha;
		// 後片付け
		invalidate fillLayer;
	}

	/**
	 * 影を追加する
	 * @param dx 影のX移動量 (右にプラス)
	 * @param dy 影のY移動量 (下にプラス)
	 * @param blur ぼかし量
	 * @param shadowColor 影の色
	 * @param shadoAlpha 影の不透明度
	 */
	function doDropShadow(dx=10, dy=10, blur=3, shadowColor=0x000000, shadowOpacity=200)
	{
		var THIS = global.Layer;
		
		// 作業用レイヤ
		var work = new THIS(window, parent);
		work.setImagePos(THIS.imageLeft, THIS.imageTop);
		work.setImageSize(THIS.imageWidth, THIS.imageHeight);
		
		// 影生成処理
		var shadow = new THIS(window, parent);
		shadow.assignImages(this);
		// 塗りつぶし
		shadow.face = dfMain;
		shadow.holdAlpha = true;
		shadow.fillRect(THIS.imageLeft, THIS.imageTop, THIS.imageWidth, THIS.imageHeight, shadowColor);
		shadow.face = dfBoth;
		shadow.holdAlpha = false;
		// ぼかす
		shadow.doBoxBlur(blur, blur);
		
		// 影をコピー
		work.operateRect(THIS.imageLeft + dx, THIS.imageTop + dy, shadow, THIS.imageLeft, THIS.imageTop, THIS.imageWidth, THIS.imageHeight, ltPsNormal, shadowOpacity);
		// 自分をコピー
		work.operateRect(THIS.imageLeft, THIS.imageTop, this, THIS.imageLeft, THIS.imageTop, THIS.imageWidth, THIS.imageHeight, ltPsNormal, 255);
		
		// 画像さしかえ
		THIS.assignImages(work);
		
		// 後片付け
		invalidate work;
		invalidate shadow;
	};
}

